name: Build & test

on:
  workflow_call:
    inputs:
      AWS_REGION:
        required: false
        type: string
        default: us-east-2
      ECR_REPOSITORY:
        required: true
        type: string
      GH_SHA:
        required: true
        type: string
      HAS_UNIT_TEST:
        required: true
        type: boolean
      GH_PR_MERGED:
        required: true
        type: boolean
      GH_BRANCH_NAME:
        required: true
        type: string
      NODE_VERSION:
        required: true
        type: string
      SLACK_CHANNEL:
        required: true
        type: string
      LISTENER:
        required: false
        type: string
        default: ""
    outputs:
      IMAGE_NAME:
        description: "A FQDN of the image to be built and pushed"
        value: ${{ jobs.docker-build.outputs.IMAGE_NAME }}
      IMAGE_TAG:
        description: "Only the tag of the image"
        value: ${{ jobs.docker-build.outputs.IMAGE_TAG }}
jobs:
  docker-build:
    if: ${{ inputs.GH_PR_MERGED }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      IMAGE_NAME: ${{ steps.docker-build.outputs.IMAGE_NAME }}
      IMAGE_TAG: ${{ steps.docker-build.outputs.IMAGE_TAG }}
    env:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          ref: ${{ inputs.GH_BRANCH_NAME }}
      - name: Set credentials and tag for ECS or EKS build
        id: env-vars
        # If repository ends with dev, stg, or prod, it is an ECS deployment, and we need legacy credentials.
        # If it doesn't, it is an EKS deployment, and we need NONPROD credentials.
        run: |
          ENVIRONMENT=$(echo ${{ inputs.ECR_REPOSITORY }} | rev | cut -d'-' -f1 | rev)
          if [ $ENVIRONMENT = prod -o $ENVIRONMENT = stg -o $ENVIRONMENT = dev ];then 
            echo AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} >> $GITHUB_OUTPUT;
            echo AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} >> $GITHUB_OUTPUT;
            echo IMAGE_TAG=${{ inputs.GH_SHA }} >> $GITHUB_OUTPUT;
          else
            echo AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID_NONPROD }} >> $GITHUB_OUTPUT;
            echo AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY_NONPROD }} >> $GITHUB_OUTPUT;
            if [ ${{ inputs.GH_BRANCH_NAME }} = develop ]; then
              echo IMAGE_TAG=$(echo ${{ inputs.GH_SHA }} | cut -c1-7) >> $GITHUB_OUTPUT;
            else
              echo IMAGE_TAG=${{ inputs.GH_SHA }} >> $GITHUB_OUTPUT;
            fi
          fi
        shell: bash
      - name: Login to ECR
        id: ecr-login
        uses: Lattice-Trade/membrane-github-template-actions/composite-actions/aws/ecr-login.v1@main
        with:
          AWS_REGION: ${{ inputs.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ steps.env-vars.outputs.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ steps.env-vars.outputs.AWS_SECRET_ACCESS_KEY }}
      - name: Notify build start on slack
        uses: Lattice-Trade/github-action-slack-notify-build@main
        continue-on-error: true
        with:
          channel: ${{ inputs.SLACK_CHANNEL }}
          status: STARTED
          color: good
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_ALARMS_TOKEN }}
      - name: Build and push to ECR
        id: docker-build
        uses: Lattice-Trade/membrane-github-template-actions/composite-actions/docker/build-push.listener@staging
        with:
          LISTENER: ${{ inputs.LISTENER }}
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ inputs.ECR_REPOSITORY }}
          GH_SHA: ${{ steps.env-vars.outputs.IMAGE_TAG }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
